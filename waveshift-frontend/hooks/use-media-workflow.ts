/**
 * Â™í‰ΩìÂ§ÑÁêÜÂ∑•‰ΩúÊµÅ Hook
 * Êèê‰æõÊñá‰ª∂‰∏ä‰º†„ÄÅÂ§ÑÁêÜÂíåÁä∂ÊÄÅÁõëÂê¨ÂäüËÉΩ
 */

import { useState, useEffect, useCallback } from 'react';
import { useAuth } from '@/contexts/auth-context';
import type { MediaTask, Transcription, TranscriptionSegment } from '@/db/schema-media';

// ÂÆûÊó∂Â≠óÂπïÁ±ªÂûãÂÆö‰πâÔºà‰ªéuse-realtime-subtitles.tsËøÅÁßªÔºâ
export interface Subtitle {
  id: string;
  startTime: string;
  endTime: string;
  text: string;
  translation: string;
  speaker: string;
}

// Êó∂Èó¥Ê†ºÂºèËΩ¨Êç¢ÂáΩÊï∞
const formatTime = (ms: number): string => {
  const totalSeconds = Math.floor(ms / 1000);
  const hours = Math.floor(totalSeconds / 3600);
  const minutes = Math.floor((totalSeconds % 3600) / 60);
  const seconds = totalSeconds % 60;
  return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
};

// Â™í‰Ωì‰ªªÂä°Á±ªÂûãÔºåÂåÖÂê´ËΩ¨ÂΩï‰ø°ÊÅØ
export interface MediaTaskWithTranscription extends MediaTask {
  transcription?: Transcription & {
    segments: TranscriptionSegment[];
  };
}

// ‰∏ä‰º†ËøõÂ∫¶‰ø°ÊÅØ
interface UploadProgressInfo {
  progress: number; // ÁôæÂàÜÊØîËøõÂ∫¶
  loaded: number; // Â∑≤‰∏ä‰º†Â≠óËäÇÊï∞
  total: number; // ÊÄªÂ≠óËäÇÊï∞
  speed: number; // ‰∏ä‰º†ÈÄüÂ∫¶ (bytes/s)
  remainingTime: number; // È¢ÑËÆ°Ââ©‰ΩôÊó∂Èó¥ (seconds)
  startTime: number; // ÂºÄÂßã‰∏ä‰º†Êó∂Èó¥Êà≥
}

// Hook Áä∂ÊÄÅÊé•Âè£
interface MediaWorkflowState {
  // ‰ªªÂä°Áä∂ÊÄÅ
  task: MediaTaskWithTranscription | null;
  
  // ‰∏ä‰º†Áä∂ÊÄÅ
  isCreating: boolean;
  isUploading: boolean;
  uploadProgress: number;
  uploadProgressInfo: UploadProgressInfo | null; // ËØ¶ÁªÜËøõÂ∫¶‰ø°ÊÅØ
  uploadComplete: boolean;
  
  // Â§ÑÁêÜÁä∂ÊÄÅ
  isProcessing: boolean;
  processingComplete: boolean;
  progress: number;
  
  // üî• Êñ∞Â¢ûÔºöÂÆûÊó∂Â≠óÂπïÁä∂ÊÄÅ
  realtimeSubtitles: Subtitle[];
  isTranscribing: boolean;
  showSkeletons: boolean;
  
  // ÁªìÊûúÁä∂ÊÄÅ
  videoPreviewUrl: string | null;
  
  // ÈîôËØØÁä∂ÊÄÅ
  error: Error | null;
  uploadError: Error | null;
  processingError: Error | null;
  
  // ‰ªªÂä° ID
  taskId: string | null;
}

// Hook Êìç‰ΩúÊé•Âè£
interface MediaWorkflowActions {
  createAndUploadTask: (
    file: File, 
    options?: { targetLanguage?: string; style?: string }
  ) => Promise<void>;
  resetWorkflow: () => void;
}


export function useMediaWorkflow(): MediaWorkflowState & MediaWorkflowActions {
  const { user } = useAuth();
  
  const [task, setTask] = useState<MediaTaskWithTranscription | null>(null);
  const [taskId, setTaskId] = useState<string | null>(null);
  
  const [isCreating, setIsCreating] = useState(false);
  const [isUploading, setIsUploading] = useState(false);
  const [uploadProgress, setUploadProgress] = useState(0);
  const [uploadProgressInfo, setUploadProgressInfo] = useState<UploadProgressInfo | null>(null);
  const [uploadComplete, setUploadComplete] = useState(false);
  
  const [isProcessing, setIsProcessing] = useState(false);
  const [processingComplete, setProcessingComplete] = useState(false);
  const [progress, setProgress] = useState(0);
  
  // üî• Êñ∞Â¢ûÔºöÂÆûÊó∂Â≠óÂπïÁä∂ÊÄÅ
  const [realtimeSubtitles, setRealtimeSubtitles] = useState<Subtitle[]>([]);
  const [isTranscribing, setIsTranscribing] = useState(false);
  const [showSkeletons, setShowSkeletons] = useState(false);
  const [processedSegmentIds, setProcessedSegmentIds] = useState<Set<number>>(new Set());
  
  const [videoPreviewUrl, setVideoPreviewUrl] = useState<string | null>(null);
  
  const [error, setError] = useState<Error | null>(null);
  const [uploadError, setUploadError] = useState<Error | null>(null);
  const [processingError, setProcessingError] = useState<Error | null>(null);
  
  const [eventSource, setEventSource] = useState<EventSource | null>(null);

  const cleanupEventSource = useCallback(() => {
    if (eventSource) {
      eventSource.close();
      setEventSource(null);
    }
  }, [eventSource]);

  const resetWorkflow = useCallback(() => {
    cleanupEventSource();
    setTask(null);
    setTaskId(null);
    
    setIsCreating(false);
    setIsUploading(false);
    setUploadProgress(0);
    setUploadProgressInfo(null);
    setUploadComplete(false);
    
    setIsProcessing(false);
    setProcessingComplete(false);
    setProgress(0);
    
    // üî• ÈáçÁΩÆÂÆûÊó∂Â≠óÂπïÁä∂ÊÄÅ
    setRealtimeSubtitles([]);
    setIsTranscribing(false);
    setShowSkeletons(false);
    setProcessedSegmentIds(new Set());
    
    setVideoPreviewUrl(null);
    
    setError(null);
    setUploadError(null);
    setProcessingError(null);
  }, [cleanupEventSource]);

  const startStatusMonitoring = useCallback((taskId: string, skipTranscribingPhase: boolean = false) => {
    if (!user) return;

    const es = new EventSource(`/api/workflow/${taskId}/status`);

    es.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        
        // üî• Â§ÑÁêÜnew_segments‰∫ã‰ª∂ÔºàÂÆûÊó∂Â≠óÂπïÔºâ
        if (data.type === 'new_segments' && data.segments) {
          const newSubtitles: Subtitle[] = data.segments
            .filter((segment: any) => !processedSegmentIds.has(segment.sentenceIndex))
            .map((segment: any) => {
              const subtitle: Subtitle = {
                id: segment.sentenceIndex.toString(),
                startTime: formatTime(segment.startMs),
                endTime: formatTime(segment.endMs),
                text: segment.rawText,
                translation: segment.transText || "",
                speaker: `ËØ¥ËØù‰∫∫ ${segment.speakerId}`,
              };
              
              return subtitle;
            });

          if (newSubtitles.length > 0) {
            // Êõ¥Êñ∞Â§ÑÁêÜËøáÁöÑsegment IDs
            setProcessedSegmentIds(prev => {
              const newSet = new Set(prev);
              newSubtitles.forEach(sub => newSet.add(parseInt(sub.id)));
              return newSet;
            });
            
            // Ê∑ªÂä†Êñ∞Â≠óÂπïÂπ∂ÊéíÂ∫è
            setRealtimeSubtitles(prev => {
              const combined = [...prev, ...newSubtitles];
              return combined.sort((a, b) => parseInt(a.id) - parseInt(b.id));
            });
            
            console.log(`üì® Êî∂Âà∞${newSubtitles.length}‰∏™Êñ∞Â≠óÂπïÁâáÊÆµ`);
          }
          return; // new_segments‰∫ã‰ª∂‰∏çÈúÄË¶ÅÂ§ÑÁêÜÂÖ∂‰ªñÈÄªËæë
        }
        
        // üî• Â§ÑÁêÜ‰ªªÂä°Áä∂ÊÄÅÊõ¥Êñ∞
        if (data.error) {
          setError(new Error(data.error));
          setIsProcessing(false);
          es.close();
          return;
        }

        setTask(data);
        setProgress(data.progress || 0);

        if (data.status === 'transcribing') {
          // üî• ËøõÂÖ•ËΩ¨ÂΩïÈò∂ÊÆµÔºöÊòæÁ§∫Â≠óÂπïÁªÑ‰ª∂ÂíåÈ™®Êû∂Â±è
          setIsTranscribing(true);
          setShowSkeletons(true);
          setIsProcessing(true);
        } else if (data.status === 'completed') {
          // üî• ËΩ¨ÂΩïÂÆåÊàêÔºöÁªìÊùüËøõÂ∫¶Êù°Ôºå‰øùÊåÅÂ≠óÂπïÊòæÁ§∫
          setIsTranscribing(false);
          setShowSkeletons(false);
          setIsProcessing(false);
          setProcessingComplete(true);
          setProgress(100);
          
          if (data.videoUrl) {
            setVideoPreviewUrl(data.videoUrl);
          }
          
          es.close();
        } else if (data.status === 'failed') {
          setError(new Error(data.error || 'Task failed'));
          setIsTranscribing(false);
          setIsProcessing(false);
          es.close();
        } else if (data.status === 'separating' || data.status === 'processing') {
          setIsProcessing(true);
        } else if (data.status === 'uploaded') {
          setIsUploading(false);
          setUploadComplete(true);
        }
      } catch (err) {
        console.error('Error parsing SSE message:', err);
      }
    };

    es.onerror = (err) => {
      console.error('EventSource error:', err);
      setError(new Error('Connection error'));
      setIsProcessing(false);
      es.close();
    };

    setEventSource(es);
  }, [user]);


  const uploadFileWithPresignedUrl = async (
    file: File,
    taskId: string,
    objectName: string,
    onProgress: (progress: number) => void
  ): Promise<string> => {
    try {

      const presignedResponse = await fetch('/api/upload/presigned-url', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          taskId,
          objectName,
          fileSize: file.size,
          mimeType: file.type,
          expiresIn: 3600,
        }),
      });

      if (!presignedResponse.ok) {
        const errorData = await presignedResponse.json() as { error?: string };
        throw new Error(errorData.error || 'Ëé∑ÂèñÈ¢ÑÁ≠æÂêçURLÂ§±Ë¥•');
      }

      const { presignedUrl, publicUrl } = await presignedResponse.json() as {
        presignedUrl: string;
        publicUrl: string;
        expiresAt: string;
      };

      return new Promise<string>((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        const startTime = Date.now();
        const progressHistory: Array<{ time: number; loaded: number }> = [];

        xhr.upload.addEventListener('progress', (event) => {
          if (event.lengthComputable) {
            const progress = Math.round((event.loaded / event.total) * 100);
            const currentTime = Date.now();
            
            progressHistory.push({ time: currentTime, loaded: event.loaded });
            
            const maxHistoryTime = 10 * 1000;
            while (progressHistory.length > 1 && 
                   currentTime - progressHistory[0].time > maxHistoryTime) {
              progressHistory.shift();
            }
            
            let speed = 0;
            if (progressHistory.length >= 2) {
              const oldestRecord = progressHistory[0];
              const latestRecord = progressHistory[progressHistory.length - 1];
              const timeDiff = (latestRecord.time - oldestRecord.time) / 1000;
              const bytesDiff = latestRecord.loaded - oldestRecord.loaded;
              speed = timeDiff > 0 ? bytesDiff / timeDiff : 0;
            }
            
            const remainingBytes = event.total - event.loaded;
            const remainingTime = speed > 0 ? remainingBytes / speed : 0;
            
            const progressInfo: UploadProgressInfo = {
              progress,
              loaded: event.loaded,
              total: event.total,
              speed,
              remainingTime,
              startTime
            };
            
            setUploadProgressInfo(progressInfo);
            onProgress(progress);
          }
        });

        xhr.addEventListener('load', async () => {
          if (xhr.status === 200) {
            try {
              await fetch('/api/upload/confirm-upload', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ taskId, objectName, fileSize: file.size }),
              });
            } catch (confirmError) {
              console.warn('Êï∞ÊçÆÂ∫ìÁä∂ÊÄÅÊõ¥Êñ∞Â§±Ë¥•Ôºå‰ΩÜÊñá‰ª∂Â∑≤ÊàêÂäü‰∏ä‰º†:', confirmError);
            }
            
            resolve(publicUrl);
          } else {
            reject(new Error(`‰∏ä‰º†Â§±Ë¥•: HTTP ${xhr.status} ${xhr.statusText}`));
          }
        });

        xhr.addEventListener('error', () => {
          reject(new Error('‰∏ä‰º†ÁΩëÁªúÈîôËØØ'));
        });

        xhr.addEventListener('timeout', () => {
          reject(new Error('‰∏ä‰º†Ë∂ÖÊó∂'));
        });

        xhr.open('PUT', presignedUrl);
        xhr.setRequestHeader('Content-Type', file.type || 'application/octet-stream');
        xhr.timeout = 10 * 60 * 1000;
        xhr.send(file);
      });
      
    } catch (error) {
      console.error('È¢ÑÁ≠æÂêçURL‰∏ä‰º†Â§±Ë¥•:', error);
      throw error;
    }
  };

  const createAndUploadTask = useCallback(async (
    file: File,
    options: { targetLanguage?: string; style?: string } = {}
  ) => {
    if (!user?.id) {
      setError(new Error('User not authenticated'));
      return;
    }

    resetWorkflow();
    setIsCreating(true);

    try {
      const createResponse = await fetch('/api/workflow/create', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          fileName: file.name,
          fileSize: file.size,
          mimeType: file.type,
          targetLanguage: options.targetLanguage || 'chinese',
          style: options.style || 'normal',
        }),
      });

      if (!createResponse.ok) {
        const errorData = await createResponse.json() as { error?: string };
        throw new Error(errorData.error || 'Failed to create task');
      }

      const result = await createResponse.json() as { taskId: string; objectName: string };
      const { taskId: newTaskId, objectName } = result;
      setTaskId(newTaskId);
      setProgress(10);

      setIsCreating(false);
      setIsUploading(true);
      
      const publicUrl = await uploadFileWithPresignedUrl(file, newTaskId, objectName, setUploadProgress);
      
      setIsUploading(false);
      setUploadComplete(true);
      setProgress(30);
      setVideoPreviewUrl(publicUrl);

      setIsProcessing(true);
      setProcessingError(null);
      await new Promise(resolve => setTimeout(resolve, 500));

      const processResponse = await fetch(`/api/workflow/${newTaskId}/process`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          targetLanguage: options.targetLanguage || 'chinese',
          style: options.style || 'normal',
        }),
      });

      if (!processResponse.ok) {
        const errorData = await processResponse.json() as { error?: string };
        console.error('Process API error:', errorData);
        throw new Error(errorData.error || 'Failed to start processing');
      }

      setProgress(50);
      startStatusMonitoring(newTaskId);

    } catch (err: any) {
      console.error('Â∑•‰ΩúÊµÅÂàõÂª∫ÊàñÂ§ÑÁêÜÂ§±Ë¥•:', err);
      const errorObj = err instanceof Error ? err : new Error(String(err));
      
      if (isCreating) {
        setError(errorObj);
        setIsCreating(false);
      } else if (isUploading) {
        setUploadError(errorObj);
        setIsUploading(false);
      } else {
        setProcessingError(errorObj);
        setIsProcessing(false);
      }
    }
  }, [user, resetWorkflow, startStatusMonitoring, isCreating, isUploading]);

  useEffect(() => {
    return () => {
      cleanupEventSource();
    };
  }, [cleanupEventSource]);

  return {
    task,
    isCreating,
    isUploading,
    uploadProgress,
    uploadProgressInfo,
    uploadComplete,
    isProcessing,
    processingComplete,
    progress,
    // üî• ÂØºÂá∫ÂÆûÊó∂Â≠óÂπïÁä∂ÊÄÅ
    realtimeSubtitles,
    isTranscribing,
    showSkeletons,
    videoPreviewUrl,
    error,
    uploadError,
    processingError,
    taskId,
    createAndUploadTask,
    resetWorkflow,
  };
}